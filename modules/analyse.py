import io, gzip
from dataclasses import dataclass, astuple

'''
analyse.py, handles the analysis of 'extract' output
'''

'''
What this needs to do:
    * calculate tail length             DONE
    * count nucleotides                 DONE
    * assign strand                     DONE
    * assign tail type:                 DONE
        all G or C -> G/C               DONE
        Empty (len = 0) -> no_tail      DONE
        all T -> polyU                  DONE
        all A -> polyA                  DONE
        A or T -> mixed_AU              DONE
        otherwise -> other              DONE
    * Count terminal Us (Ts)            DONE
'''

class ExtractFile:
    def __init__(self, path: str):
        self.path = path

    #
    # File handling methods
    #

    def _get_header(self):
        '''
        Internal method, used for reading the header of input text file.

        Args:
            handle: file handle generated by one of the open(file, 'r') variants, eg. gzip.open(file, 'rt')

        Returns:
            list[str, ...]: header as a \t separated list of strings
        '''
        return self.handle.readline().strip().split('\t')

    def open_gzip(self):
        '''
        Opens a gzipped file for reading as text and stores its 1st line (header) separately
        '''
        self.handle = gzip.open(self.path, "rt")
        self.header = self._get_header()

    def open_plain(self):
        '''
        Opens a plain text file for reading and stores its 1st line (header) separately
        '''
        self.handle = open(self.path, 'r')
        self.header = self._get_header()

    def close(self):
        '''
        For closing the file after reading
        '''
        self.handle.close()

    def _line_process(self, line):
        '''
        Used for processing the input lines into manageable data structures (only lists for now)
        '''
        return line.strip().split('\t')

    def __iter__(self):
        '''
        Return object iterator
        '''
        return self

    def __next__(self):
        '''
        Define how to get the next element, i.e. line
        '''
        line = self.handle.readline()
        self.line = self._line_process(self.handle.readline())
        if line:
            self.line = self._line_process(line)
        else:
            raise StopIteration

    #
    # File processing/analysis methods
    #

    def tail_len(self):
        '''
        Calculate tail length (CLIP3 field)
        '''
        if self.line[5] != "NA":
            return len(self.line[5])
        else:
            return 0

    def count_bases(self):
        '''
        Count bases for 3' tail sequence
        '''
        tail_seq = self.line[5]

        if tail_seq != "NA":
            return tuple([tail_seq.count('A'),
                          tail_seq.count('C'),
                          tail_seq.count('G'),
                          tail_seq.count('T')])
        else:
            return tuple([0, 0, 0, 0])

    def get_strand(self):
        '''
        Get mapping strand from SAM flags. Flags are stored as `int:12-bit`
        format, eg. 123:000001111011.

        Outputs the Entrez strand convention, i.e. + = 1, - = -1
        '''
        flags = bin(int(self.line[1].split(':')[0]))

        # 5th bit is "REVERSE - SEQ is reverse complemented"
        return -1 if flags[-5] else 1

    def tail_type(self) -> str:
        '''
        Assign a tail type based on it's base composition

        Args:
            base_counts (tuple): (A, C, G, T)

        Returns:
            str: tail type, one of: no_tail, polyU, polyA, mixed_AU, mixed_GC,
                other
        '''
        base_counts = self.count_bases()
        total = sum(base_counts)
        if total == 0:
            return "no_tail"

        elif base_counts[3] == total:
            return "polyU"

        elif base_counts[0] == total:
            return "polyA"

        elif base_counts[0] + base_counts[3] == total:
            return "mixed_AU"

        elif base_counts[2] + base_counts[3] == total:
            return "mixed_GC"

        else:
            return "other"

    def count_Us(self):
        tail = self.line[5]
        u_count = 0

        for i in range(1, len(tail) + 1):
            if tail[-i] == 'T':
                u_count += 1
            else:
                break

        return u_count

    def header_format(self):
        '''
        Prepare header for printing to file
        '''
        outhdr = '\t'.join(self.header + ["TAIL_LEN", 
                                          "A", "C", "G", "U",
                                          "STRAND", "TYPE",
                                          "U_COUNT"]) + '\n'

        return outhdr

    def line_format(self):
        '''
        Prepare line for writing to file
        '''
        return '\t'.join(self.line + [str(self.tail_len()),
                                      '\t'.join([str(i) for i in self.count_bases()]),
                                      str(self.get_strand()),
                                      self.tail_type(),
                                      str(self.count_Us())]) + '\n'

def analyser(infile: str, out_name: str, briefmode: bool) -> None:

    f = ExtractFile(infile)
    f.open_gzip()

    if briefmode:
        with gzip.open(f"{out_name}.tsv.gz", "wt") as fo:

            fo.write(f.header_format())

            for line in f:
                if f.tail_type() != "no_tail":
                    fo.write(f.line_format())
    else:
        with gzip.open(f"{out_name}.tsv.gz", "wt") as fo:

            fo.write(f.header_format())

            for line in f:
                fo.write(f.line_format())

    f.close()

    return None
